{
  "version": 3,
  "sources": ["../../@turf/bearing/dist/es/index.js", "../../@turf/destination/dist/es/index.js", "../../@turf/along/dist/es/index.js"],
  "sourcesContent": ["import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nexport default function bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n", "// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n", "import bearing from \"@turf/bearing\";\nimport destination from \"@turf/destination\";\nimport measureDistance from \"@turf/distance\";\nimport { point } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Takes a {@link LineString} and returns a {@link Point} at a specified distance along the line.\n *\n * @name along\n * @param {Feature<LineString>} line input line\n * @param {number} distance distance along the line\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} Point `distance` `units` along the line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);\n * var options = {units: 'miles'};\n *\n * var along = turf.along(line, 200, options);\n *\n * //addToMap\n * var addToMap = [along, line]\n */\nexport default function along(line, distance, options) {\n    if (options === void 0) { options = {}; }\n    // Get Coords\n    var geom = getGeom(line);\n    var coords = geom.coordinates;\n    var travelled = 0;\n    for (var i = 0; i < coords.length; i++) {\n        if (distance >= travelled && i === coords.length - 1) {\n            break;\n        }\n        else if (travelled >= distance) {\n            var overshot = distance - travelled;\n            if (!overshot) {\n                return point(coords[i]);\n            }\n            else {\n                var direction = bearing(coords[i], coords[i - 1]) - 180;\n                var interpolated = destination(coords[i], overshot, direction, options);\n                return interpolated;\n            }\n        }\n        else {\n            travelled += measureDistance(coords[i], coords[i + 1], options);\n        }\n    }\n    return point(coords[coords.length - 1]);\n}\n"],
  "mappings": ";;;;;;;;;;;;AA0Be,SAAR,QAAyB,OAAO,KAAK,SAAS;AACjD,MAAI,YAAY,QAAQ;AAAE,cAAU,CAAC;AAAA,EAAG;AAExC,MAAI,QAAQ,UAAU,MAAM;AACxB,WAAO,sBAAsB,OAAO,GAAG;AAAA,EAC3C;AACA,MAAI,eAAe,SAAS,KAAK;AACjC,MAAI,eAAe,SAAS,GAAG;AAC/B,MAAI,OAAO,iBAAiB,aAAa,CAAC,CAAC;AAC3C,MAAI,OAAO,iBAAiB,aAAa,CAAC,CAAC;AAC3C,MAAI,OAAO,iBAAiB,aAAa,CAAC,CAAC;AAC3C,MAAI,OAAO,iBAAiB,aAAa,CAAC,CAAC;AAC3C,MAAI,IAAI,KAAK,IAAI,OAAO,IAAI,IAAI,KAAK,IAAI,IAAI;AAC7C,MAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAClC,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,OAAO,IAAI;AAC1D,SAAO,iBAAiB,KAAK,MAAM,GAAG,CAAC,CAAC;AAC5C;AASA,SAAS,sBAAsB,OAAO,KAAK;AAEvC,MAAI,OAAO,QAAQ,KAAK,KAAK;AAC7B,UAAQ,OAAO,OAAO;AACtB,SAAO;AACX;;;AC1Be,SAAR,YAA6B,QAAQ,UAAUA,UAAS,SAAS;AACpE,MAAI,YAAY,QAAQ;AAAE,cAAU,CAAC;AAAA,EAAG;AAExC,MAAI,eAAe,SAAS,MAAM;AAClC,MAAI,aAAa,iBAAiB,aAAa,CAAC,CAAC;AACjD,MAAI,YAAY,iBAAiB,aAAa,CAAC,CAAC;AAChD,MAAI,aAAa,iBAAiBA,QAAO;AACzC,MAAI,UAAU,gBAAgB,UAAU,QAAQ,KAAK;AAErD,MAAI,YAAY,KAAK,KAAK,KAAK,IAAI,SAAS,IAAI,KAAK,IAAI,OAAO,IAC5D,KAAK,IAAI,SAAS,IAAI,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,UAAU,CAAC;AAClE,MAAI,aAAa,aACb,KAAK,MAAM,KAAK,IAAI,UAAU,IAAI,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,SAAS,GAAG,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,SAAS,IAAI,KAAK,IAAI,SAAS,CAAC;AAC5I,MAAI,MAAM,iBAAiB,UAAU;AACrC,MAAI,MAAM,iBAAiB,SAAS;AACpC,SAAO,MAAM,CAAC,KAAK,GAAG,GAAG,QAAQ,UAAU;AAC/C;;;ACvBe,SAAR,MAAuB,MAAM,UAAU,SAAS;AACnD,MAAI,YAAY,QAAQ;AAAE,cAAU,CAAC;AAAA,EAAG;AAExC,MAAI,OAAO,QAAQ,IAAI;AACvB,MAAI,SAAS,KAAK;AAClB,MAAI,YAAY;AAChB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,QAAI,YAAY,aAAa,MAAM,OAAO,SAAS,GAAG;AAClD;AAAA,IACJ,WACS,aAAa,UAAU;AAC5B,UAAI,WAAW,WAAW;AAC1B,UAAI,CAAC,UAAU;AACX,eAAO,MAAM,OAAO,CAAC,CAAC;AAAA,MAC1B,OACK;AACD,YAAI,YAAY,QAAQ,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC,IAAI;AACpD,YAAI,eAAe,YAAY,OAAO,CAAC,GAAG,UAAU,WAAW,OAAO;AACtE,eAAO;AAAA,MACX;AAAA,IACJ,OACK;AACD,mBAAa,WAAgB,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,GAAG,OAAO;AAAA,IAClE;AAAA,EACJ;AACA,SAAO,MAAM,OAAO,OAAO,SAAS,CAAC,CAAC;AAC1C;",
  "names": ["bearing"]
}
